%-----------------------------------------------------------------------
% Beginning of jams-l-template.tex
%-----------------------------------------------------------------------
%
%     This is a topmatter template file for JAMS for use with AMS-LaTeX.
%
%     Templates for various common text, math and figure elements are
%     given following the \end{document} line.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%     Remove any commented or uncommented macros you do not use.

\documentclass{acmart}

%     If you need symbols beyond the basic set, uncomment this command.
%\usepackage{amssymb}

%     If your article includes graphics, uncomment this command.
%\usepackage{graphicx}

%     If the article includes commutative diagrams, ...
%\usepackage[cmtip,all]{xy}


%     Update the information and uncomment if AMS is not the copyright
%     holder.
%\copyrightinfo{2009}{American Mathematical Society}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{lemma}[theorem]{Lemma}

%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{example}[theorem]{Example}
%\newtheorem{xca}[theorem]{Exercise}

\theoremstyle{remark}

\numberwithin{equation}{section}

\usepackage{graphicx}
\usepackage[margin=1.1in]{geometry}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{etex}
\usepackage{color}
\usepackage{graphicx}
\usepackage{esint}
\usepackage{stmaryrd}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage[squaren]{SIunits}
\usepackage[tight]{subfigure}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{sketch}{Sketch of Proof}
\newtheorem{example}{Example}
\newtheorem{operation}{Operation}

\newcommand{\mb}{\overline{\mathcal{M}}}
\newcommand{\mm}{\mathcal{M}}
\newcommand{\ee}{\mathcal{L}}
\newcommand{\kk}{\mathcal{K}}
\newcommand{\lm}{\textnormal{lm}}
\newcommand{\rr}{\mathcal{R}}
\newcommand{\pp}{\mathcal{P}}
\newcommand{\ints}{\mathbb{Z}}
\newcommand{\nn}{\mathcal{N}}
\newcommand{\ar}{\mathcal{A}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\la}{\left\langle}
\newcommand{\ra}{\right\rangle}
\newcommand{\red}{\textnormal{red}}
\newcommand{\cor}{\textnormal{Corr}}
\newcommand{\pe}{\textnormal{Per}}
\newcommand{\inn}{\textnormal{Inn}}
\newcommand{\reg}{\textnormal{reg}}
\newcommand{\supp}{\textnormal{supp}}
\newcommand{\mut}{\textnormal{MutNorm}}
\newcommand{\bas}{\textnormal{base}}
\newcommand{\ngen}{\textnormal{NormGen}}
\newcommand{\intt}{\textnormal{Int}}
\newcommand{\gen}{\textnormal{gen}}
\newcommand{\norm}{\textnormal{norm}}
\newcommand{\maxn}{\textnormal{MaxNorm}}
\newcommand{\act}{\textnormal{act}}
\newcommand{\aff}{\mathbb{A}}
\newcommand{\affn}{\mathbb{A}^n}
\newcommand{\spa}{\textnormal{ }}
\newcommand{\lcm}{\textnormal{lcm}}
\newcommand{\divi}{\textnormal{div}}
\newcommand{\Reg}{\textnormal{Reg}}
\newcommand{\spec}{\textnormal{Spec}}
\newcommand{\conv}{\textnormal{Conv}}
\newcommand{\cone}{\textnormal{Cone}}
\newcommand{\ff}{\mathbb{F}}
\newcommand{\minpol}{\textnormal{MinPoly}_{\mathbb{F}_q}}
\newcommand{\modu}{\textnormal{ mod }}

\newcommand{\frakf}{\mathfrak{f}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\for}{\textbf{for}}
\newcommand{\from}{\textbf{from}}








\begin{document}

\title[AMS Article Template]{Fast Algorithms for Computing the Characteristic Polynomial of a Rank-2 Drinfeld Module}
% \title[short text for running head]{full title}

%    Only \author and \address are required; other information is
%    optional.  Remove any unused author tags.

%    author one information
% \author[short version for running head]{name for top of paper}
\author{}
\address{}
\curraddr{}
\email{}
\thanks{}

%    author two information
\author{}
\address{}
\curraddr{}
\email{}
\thanks{}

%    \subjclass is required.
\subjclass[2010]{Primary }

\date{}

\dedicatory{}

%    Abstract is required.
\begin{abstract}
\end{abstract}

\maketitle


\section{Introduction}

Motivated by finding analogues of classical point counting techniques for Rank-2 Drinfeld modules, we introduce two new algorithms which provide a runtime complexity improvement over previous algorithms given by Gekeler in .

\section{Preliminaries}

\subsection{Algorithmic Concepts}

In determining the complexity of the algorithms presented, two computational models will be used:

\begin{itemize}
\item an algebraic model for algorithms over a ring or field, in which the standard ring operations of addition and multiplication can be performed at unit cost.

\item a boolean model which counts bit complexity of all operations.
\end{itemize}

The algebraic model will typically be preferred, however the Kedlaya-Umans algorithm for modular composition does not always admit an algebraic algorithm. Algorithms utilizing modular composition will have their complexity given in both an algebraic and boolean model.

\begin{operation}[Matrix Multiplication]

Let $R$ be a ring, and let $M$ be an $m\times n$ matrix, and $N$ an $n \times \ell$ matrix, both with entries contained in $R$. Compute $M\times N$.

\end{operation}

We will let $\omega$ denote an exponent such that two $n\times n$ matrices can be multiplied using $O(n^{\omega})$ ring operations in any ring $R$. The current best known bound is $\omega \approx 2.3728$ \cite{DBLP:journals/corr/abs-1708-05622}. Similarly, we let $\omega_2$ denote the exponent of $n \times n$ and $n \times n^2$ multiplication, with the best known bound of $\omega_2 < 3.2516$ \cite{DBLP:journals/corr/abs-1708-05622}, and naively $\omega_2 \leq \omega + 1$.

\subsection{Drinfeld Modules}

\begin{definition}

Let $F$ be a function field with a place $\infty$, and $A$ a sub-ring of $F$ of elements regular at every point except possibly $\infty$ containing the field $\mathbb{F}_q$ for a prime power $q$. Consider a map $\gamma : A \to L$ and set $\sigma : a \mapsto a^q$. Then a \textbf{Drinfeld $A$-module} over $L$ is an injective morphism $\phi: A \to L[X,\sigma]$ such that 

\[\phi(a) = \gamma(a) + a_1 X + \ldots a_rX^r \]

\noindent With the further requirement that $r \geq 1 $ and $a_r \neq 0$ for at least one $a \in A$.

\end{definition}

There is a simpler construction when $L$ is an extension of a finite field $\mathbb{F}_q$, say $L = \mathbb{F}_q[T]/\mathfrak{f} = \mathbb{F}_{q^n}$ for some monic irreducible  $\frakf \in \mathbb{F}_q[T]$ of degree $n$. Here we have $A = \mathbb{F}_{q}[T]$, and we fix an inclusion $\gamma: A \to L$ where $\ker(\gamma)$ is a prime ideal of $A$ generated by a monic irreducible polynomial $\mathfrak{p}$ of degree $d$ referred to as the $A$-\textit{Characteristic} of $L$. Then $K = A/\mathfrak{p}$ and $\gamma(a)$ represents the canonical mapping of $a \in A$ into $L$. Let $m := [L : K]$. Finally, let $\sigma : L \to L$ be the order $q$ Frobenius map. Then a Drinfeld module is a ring homomorphism $\phi: A \to L[X,\sigma]$ such that 

\[\phi(a) = \gamma(a) + a_1 X + \ldots a_rX^r\]

\noindent and $r \geq 1 $ and $a_r \neq 0$ for at least one $a \in A$. This will be the definition we will make use of. If $a = T$, a Drinfeld Module is completely specified by the parameters $(q,\frakf, \mathfrak{p}, a_1, \ldots, a_r)$ or as $(q,\frakf, \mathfrak{p}, \phi_T)$, though we will frequently drop the references to $q$,$\frakf$, and $\mathfrak{p}$. Since each of these parameters can be specified with coefficients in $\mathbb{F}_q$, all cost analysis will be done in the algebraic model using $\mathbb{F}_q$ operations unless specified otherwise.

%Moreover define $K = A / \mathfrak{p}$, 

%Fix an irreducible $\mathfrak{p} \in A$ of degree $m$ and 

\begin{example}
Let $q = 2$, $A = \mathbb{F}_2[T]$, $f = T^2 + T + 1$, and $L = A/f = \mathbb{F}_4$. Then let $\gamma: A \to L$ be the quotient map by $f$ and define the Drinfeld Module $\phi: A \to L$ as

\[ \phi_T = T + X + X^2\]

\end{example}

We will often write $\phi_a$ in place of $\phi(a)$. Since $\phi$ is a ring homomorphism, we have $\phi_{ab} = \phi_a \phi_b$, and so the Drinfeld module is determined entirely by $\phi_T$; the degree of $\phi_T$ is referred to as the \textit{rank} of the Drinfeld Module. 

There is a map $\iota$ of elements of $L[X, \sigma]$ into $End_{\mathbb{F}_q}[L]$ given by:

\[\iota: a_0 + a_1X + a_2X^2 + \ldots \mapsto a_0 I + a_1 \sigma + a_2 \sigma^2 + \ldots \]

\noindent where $I: L \to L$ is the identity operator. This mapping is a ring homomorphism, and given a Drinfeld module $\phi$ we will interpret elements $\phi_a$ as operators $L \to L$ under this association for all $a \in A$.

We will restrict our consideration to rank-2 Drinfeld modules, which are widely viewed in the literature as a direct function field analogue of elliptic curves \cite{GEKELE1991187}. Letting $\phi_T = \gamma(T) + g X + \Delta X^2$, we can represent any rank-2 Drinfeld module with the pair $(g,\Delta)$. From \cite{frobdist}, we have the following theorem. 
\begin{theorem}\label{charpoly}
Suppose $\phi$ is a rank-2 Drinfeld module over $L$, a degree $n$ extension of $\mathbb{F}_q$, and suppose $\sigma$ is the order $q$ Frobenius map. Then there is a polynomial $T^2 -aT + b \in A[T]$ such that the absolute Frobenius operator $\tau = \sigma^n: L \to L$  satisfies the characteristic equation
\end{theorem}


\begin{equation} \tau^2 - \phi_a \tau + \phi_b = 0 \end{equation}

\noindent as an element of $L[X,\sigma]$ under $\iota$; that is, $(X^n)^2 - \phi_a X^n + \phi_b = 0$ in $L[X,\sigma]$. The coefficients $a$ and $b$ are referred to as the \textit{Frobenius trace} and \textit{Frobenius norm} respectively. 

The main goal of this paper is to find efficient algorithms to solve the following problem.

\begin{operation}[Computing the Characteristic Polynomial]
Given a rank-2 Drinfeld module $\phi = (g,\Delta)$, compute its Frobenius Trace and Norm.
\end{operation}

\section{An Algorithm for the Characteristic Map}

One of the most basic operations that can be performed on a Drinfeld module is the computation of $\phi_a \in L[X,\sigma]$ for an arbitrary element $a = \sum_{i=0}^d a_i T^i \in A$.

\begin{operation}[Evaluating the Characteristic Map]
Given a Drinfeld Module $\phi: A \to L$ and an element $a \in A$, compute $\phi_a$. 
\end{operation}

Let $\theta$ be the exponent such that two skew-polynomials in $\mathbb{F}_{q^m}[X,\sigma]$ of degree at most $e$ can be multiplied in $O(e^{\theta})$ $\mathbb{F}_q$ operations, dropping dependence on all other parameters. Since $\phi$ is a ring homomorphism, we have that:

\[ \phi : \sum_{i = 0}^d a_iT^i \mapsto \sum_{i = 0}^d a_i\phi_T^i \]

\noindent which leads to a naive algorithm for computing $\phi_a$ by computing $\phi_T^i$ via skew-polynomial multiplication for all $2 \leq i \leq d$, which works for any rank $r$ Drinfeld Module. This involves at least $d/2$ multiplications of skew-polynomials of degree at least $rd/2$, and therefore has a complexity of $\Omega(d^{\theta + 1})$. 

\begin{theorem}
There is an algorithm that evaluates the characteristic map of any finite Drinfeld module $(q,\frakf,\mathfrak{p}, \phi_T)$ of rank $r$ at an element $a \in \mathbb{F}_q[T]$ of degree at most $d$ in $\widetilde{O}(n^{2} rd \log q)$ $\mathbb{F}_q$ operations.
\end{theorem}

\begin{proof}
Given an element $a \in \mathbb{F}_q[T]$, without loss of generality we may assume $\deg(a) = d = 2^{e}$ for some integer $e$. Then we may factor $a$ as

\[a = b + T^{d/2} c \] 

\noindent with $\deg(b), \deg(c) \leq d/2$. We then have:

\[\phi_a = \phi_b + \phi_{T^{d/2}} \phi_c\]

\noindent where each of $\phi_b$, $\phi_{T^{d/2}}$, and $\phi_c$ have degree at most $\frac{rd}{2}$ in $X$. This suggests a divide and conquer algorithm which recursively computes $\phi_b, \phi_c$ and $\phi_{T^{d/2}} = \phi_{T^{d/4}}\phi_{T^{d/4}}$ when $e \geq 2$, with runtime $O(t(n,dr))$ $\mathbb{F}_q$ operations for some $t$ depending on $n$, $d$, $q$, and $r$. Suppressing the dependence on $n$ and $q$, set $\overline{d} = rd$ and $\hat{t}(\overline{d}) = t(n, d, q, r)$. Using the Caruso-Le Borgne algorithm for skew multiplication twice to compute $\phi_{T^{d/2}}$ and $\phi_{T^{d/2}} \phi_c$, which from theorems \ref{smalldeg} and \ref{bigdeg} has worst case runtime $O(\overline{d}n^2 \log q)$ for any value of $\overline{d}$, $n$, and $q$, to recombine the subproblems, we obtain the following recurrence:

\[ \hat{t}(\overline{d}) = 2 \hat{t}(\overline{d}/2) + O(\overline{d}).\]

\noindent Therefore $\hat{t} \in O( \overline{d} \log \overline{d})$, and $O(t(n,d,r)) \in O(m^2 rd \log (rd) \log q)$.

\end{proof}

\begin{algorithm}
\caption{Evaluating the Drinfeld Characteristic Map}\label{charmap}
\begin{algorithmic}[1]
\Procedure{CharMapEval}{} \\
 \hspace*{\algorithmicindent} \textbf{Background} A Drinfeld Module $(q,\frakf,\mathfrak{p}, \phi_T)$ \\
 \hspace*{\algorithmicindent} \textbf{Input} An element $a \in A$ \\
 \hspace*{\algorithmicindent} \textbf{Output} $\phi_a$
 \State $a := \sum_{i=0}^d a_i T^i$
 \If{$\deg(a) \leq 1$}
 \Return $a_0 + a_1 \phi_T$
 \EndIf
 \State $b \gets \sum_{i=0}^{\floor{d/2}}a_iT^i$
 \State $c \gets \sum_{i = 0}^{\floor{d/2}}a_{i + \ceil{d/2}} T^i$
 \State $\textbf{Memoize } \phi_{\floor{d/2}} \gets \textbf{SkewMultiplication}(\phi_{\floor{\floor{d/2}/2}}, \phi_{\floor{\floor{d/2}/2}}) $
\If{$d$ is odd}
\State $\phi_{\ceil{d/2}} \gets \textbf{SkewMultiplication}(\phi_{\floor{\floor{d/2}/2}}, \phi_{T}) $
\Else 
\State $\phi_{\ceil{d/2}} \gets \phi_{\floor{d/2}}$ 
\EndIf
\State $\phi_b \gets \textbf{CharMapEval}(b)$
\State $\phi_c \gets \textbf{CharMapEval}(c)$

 \Return $\phi_b + \textbf{SkewMultiplication}(\phi_{\ceil{d/2}}, \phi_c)$

\EndProcedure
\end{algorithmic}
\end{algorithm}


%\begin{algorithm}
%\caption{Evaluating the Drinfeld Characteristic Map}\label{charmap}
%\begin{algorithmic}[1]
%\Procedure{CharMapEval}{} \\
% \hspace*{\algorithmicindent} \textbf{Input} A Drinfeld Module $(q,\frakf,\mathfrak{p}, \phi_T)$ and an element $a \in A$ \\
% \hspace*{\algorithmicindent} \textbf{Output} $\phi_a$
% \State $\phi_a \gets a \textnormal{ mod } \mathfrak{p}$
%\For{$i=0 \textbf{ to }\deg(a)$}
%\State $\phi_{T}^i \gets SkewPolynomialMultiplication( \phi_T^{i-1}, \phi_T) $
%\State $\phi_a \gets  \phi_a + a_i \cdot \phi_T^i$
%\EndFor

%\State \textbf{Return } $\phi_a$

%\EndProcedure
%\end{algorithmic}
%\end{algorithm}
\section{Previous Algorithms for Computing the Characteristic Polynomial of the Frobenius Map}

\subsection{Gekeler's Algorithm}

 Determining the Frobenius norm is done using the following theorem from \cite{frobdist}:

\begin{theorem}\label{frobnorm}
The Frobenius norm $b$ of a rank-2 Drinfeld Module $(g,\Delta)$ is given by:

\[b = (-1)^n N_{\mathbb{F}_{q^n}/\mathbb{F}_q}(\Delta)^{-1}\mathfrak{p}^m\]

Furthermore, the above expression can be determined in $O(M(n)\log n)$ $\mathbb{F}_q$ operations.

\end{theorem}

\begin{proof}
We will provide only the cost analysis, which is new. Note $\mathfrak{p}^m$  is a degree $n$ polynomial and can compute $\mathfrak{p}^m$ in time $O(M(n) \log m)$ $\mathbb{F}_q$ operations. Moreover $N_{L/\mathbb{F}_q}(\Delta) = \pm \textnormal{res}(\Delta,\frakf)$ \cite{Pohst:1989:AAN:76692}, which can be computed in $O(M(n)\log n)$ $\mathbb{F}_q$ operations \cite{Pohst:1989:AAN:76692}.
\end{proof}

%Determining $\mathfrak{p}$ can be done by determining the kernel of $\gamma$, and $\mathfrak{p}^m$ can be determined with Brent-Kung modular composition, adding a runtime cost of $O(n^{\omega})$. Recalling that $N_{L/\mathbb{F}_q}(\Delta) =  \Delta^{\frac{q^{n}-1}{q-1} } $, it can be computed in time $O(n \log(q))$.


%$\mathfrak{p}$ can be determined as the 
%The above computation has a worst case complexity of $n^{\omega}$ to compute $N_{L/\mathbb{F}_q}(\Delta)^{-1}$.

Gekeler in \cite{frobdist} gives a general algorithm that determines the Frobenius trace  for any rank-2 Drinfeld module. We present that algorithm now, together with a new cost analysis which is not provided in the original paper.



\begin{theorem}

The Frobenius trace of a rank-2 Drinfeld Module $\phi = (g, \Delta)$ over $L$ can be determined in

\begin{itemize}
\item $O(n^3 \log^2 q)$ $\mathbb{F}_q$ operations
\item $O(n^{3+\epsilon} \log^{1+o(1)} q)$ bit operations for any $\epsilon > 0$.
\end{itemize}

\end{theorem}

\begin{proof}

From \cite{frobdist} we obtain that $\textnormal{deg}(a) \leq \frac{n}{2}$. Set :

\begin{align*}
a & = \sum_{i \leq n/2} a_i T^i \\
\mathfrak{p}^m & = \sum_{i \leq n} p_iT^i \\
\phi_{T^i} & = \sum_{j \leq 2i} f_{i,j} X^{j}
\end{align*}


\noindent With $a_i$,$p_i$, and $f_{i,j} \in \mathbb{F}_{q^n}$ for all choices of $i,j$, and $f_{i,0} = \gamma(T^i)$, $f_{1,1} = g$, $f_{1,2} = \Delta$. Using theorem \ref{frobnorm}, we can compute $\phi_b$ in $O(M(n)\log n)$ $\mathbb{F}_q$ operations, and by theorem \ref{charpoly} we have:

\[ \sigma^{2n} + \sum_{i \leq n/2} a_i \phi_{T^i}\sigma^n + \phi_b = 0  \]

\noindent which gives

\[ \sigma^{2n} + \sum_{i \leq n/2} a_i \sum_{j \leq 2i} f_{i,j}\sigma^{j+n} + (-1)^nN_{L/\mathbb{F}_q}(\Delta)^{-1}\sum_{i \leq n} p_i\sum_{j \leq 2i} f_{i,j} \sigma^{j} = 0.  \]

\noindent Factoring out $\sigma^{2n}$, this gives a system of $n+1$ equations

\[ - \sum_{i \leq n/2} a_i f_{i,j-n} + (-1)^n N_{L/\mathbb{F}_q}(\Delta)^{-1} \sum_{\lfloor j/2 \rfloor \leq i \leq n} p_i f_{i,j} = 0 \textnormal{ for } j < 2n \]
\noindent and
\[ - \sum_{i \leq n/2} a_i f_{i,n} + (-1)^n N_{L/\mathbb{F}_q}(\Delta)^{-1}  p_n f_{n,2n} = -1 \]

\noindent with $p_i$ already computed while determining the Frobenius norm, and $f_{i,j}$ determined using a method that is to be discussed later. From known values, we can compute
%\[\alpha_j = (-1)^nN_{L/\mathbb{F}_q}(\Delta)^{-1} \sum_{\lfloor j/2 \rfloor \leq i \leq n} p_i f_{i,j}\textnormal{ for } n \leq j < 2n\]

\begin{align*}
\alpha_j & = (-1)^nN_{L/\mathbb{F}_q}(\Delta)^{-1} \sum_{\lfloor (j+n)/2 \rfloor \leq i \leq n} p_i f_{i,j + n}\textnormal{ for } 0 \leq j < n \\
\alpha_{n} & = 1 + (-1)^nN_{L/\mathbb{F}_q}(\Delta)^{-1}  p_n f_{n,2n}
\end{align*}

Since $\lfloor \frac{n}{2} \rfloor = \lfloor \frac{n + 1}{2} \rfloor$ when $n$ is even, we have that the equations are redundant when $j \in \{n + 2i - 1 : 1 \leq i \leq \frac{n}{2} \}$ for even $n$, while for odd $n$ this occurs when $j \in \{n + 2i + 2 : 0 \leq i \leq \frac{n-1}{2}\}$. Eliminating redundancies and noting that $f_{i,j} = 0$ whenever $i < 2j$ leaves the following upper triangular system of $\lfloor\frac{n}{2}\rfloor + 1$ equations


\begin{equation}
\begin{bmatrix} f_{0,0} & f_{1,0} & \ldots & f_{\lfloor n/2 \rfloor, 0} \\
                 0      & f_{1,2} & \ldots & f_{\lfloor n/2 \rfloor, 2}  \\
                 0      & 0       & \ddots & \vdots                      \\
                 \vdots  & \vdots  &  \ddots      & \vdots                       \\
                 0  & 0 & \ldots & f_{\lfloor n/2 \rfloor, n}
\end{bmatrix}
\begin{bmatrix}
a_0 \\ a_1 \\ \vdots \\ a_{\lfloor n/2 \rfloor}
\end{bmatrix} = \begin{bmatrix} \alpha_{0} \\ \alpha_{2} \\ \vdots \\ \alpha_{n} \end{bmatrix}
\end{equation}

\noindent whose diagonal entries are $f_{i,2i}$, which are the coefficients of the leading terms of $\phi_{T^i}$, and therefore are of the form $f_{i,2i} = \Delta^e \neq 0$ for some exponent $e$ and for $0 \leq i \leq \lfloor \frac{n}{2} \rfloor$ since $\Delta \neq 0$. The upper triangular system can be solved in $O(n^2)$ $\mathbb{F}_{q^n}$ operations, and therefore $O(n^2M(n))$ $\mathbb{F}_{q}$ operations, by solving for $a_{\lfloor n/2 \rfloor}$ using $f_{\lfloor n/2 \rfloor, n}a_{\lfloor n/2 \rfloor} = \alpha_{n}$ and recursively solving for $a_i$ using the solution for $a_{i+1}, \ldots, a_{\lfloor n/2 \rfloor}$. However, determining the system requires computing $f_{i,j}$ for $i \leq n/2$, $j \leq n$. Techniques for skew polynomial multiplication offer a naive approach, however an improvement can be obtained by determining a recurrence:

\begin{align*}
 \phi_{T^{i+1}} = \phi_T \phi_{T^i} & = (\gamma(T) + gX + \Delta X^2) \sum_{j \leq 2i} f_{i,j} X^{j} \\
 &= \sum_{j \leq 2i} \gamma(T) f_{i,j} X^{j} + \sum_{j \leq 2i} g f_{i,j}^q X^{j+1} + \sum_{j \leq 2i} \Delta f_{i,j}^{q^2} X^{j+2}
\end{align*}

\noindent So the $f_{i,j}$ satisfy the recurrence

\[ f_{i+1,j} = \gamma(T) f_{i,j} + g f_{i,j-1}^q + \Delta f_{i,j-2}^{q^2}\]

%For each $i$, there are $2i$ values of $j$ on which we need to solve this recurrence, and so computing $f_{i,j}$ for fixed $i \leq \lfloor \frac{n}{2} \rfloor $ and all choices of $j$ using this recurrence takes $O(i M(n)\log q)$ field operations, 

\noindent With initial conditions $f_{0,0} = 1$, $f_{1,0} = \gamma(T)$, $f_{1,1} = g$, and $f_{1,2 = \Delta}$. Evaluating one instance of the recurrence involves three applications of the Frobenius map, which is the dominating step, and takes $O(M(n) \log q)$ $\mathbb{F}_q$ operations. There are $O(n^2)$ choices of $i$ and $j$ on which we want to evaluate this recurrence and so we obtain a worst case runtime of $O(M(n)n^2\log q)$ field operations to determine all $f_{i,j}$. Using Kedlaya-Umans modular composition, however, gives a bit operation count of $O(i n^{1 + \epsilon \log^{1 + o(1)} q})$, and computes all $f_{i,j}$ in time $O(n^{3 + \epsilon} \log^{1 + o(1)} q)$ for any constant $\epsilon > 0$. The cubic complexity in $n$ is due to the need to solve $O(n)$ recurrences to determine all $f_{i,j}$, and therefore can not be repaired in an elementary manner. 

\end{proof}


 \begin{algorithm}
\caption{Gekeler's Algorithm for the Frobenius Trace}\label{euclid}
\begin{algorithmic}[1]
\Procedure{FrobeniusTrace}{}\\
%\Input $q$ \text{ a prime power} $m$ \text{ an integer}

\hspace*{\algorithmicindent} \textbf{Input} A rank-2 Drinfeld Module $(g, \Delta)$\\
 \hspace*{\algorithmicindent} \textbf{Output} The Frobenius Trace
 
\State $f_{0,0} \gets 1$
\State $f_{1,0} \gets \gamma(T)$
\State $f_{1,1} \gets g$
\State $f_{1,2} \gets \Delta$

\For{$i=2 \textbf{ to } \lfloor \frac{n}{2} \rfloor$}
\For{$j = 1 \textbf{ to } \lfloor \frac{n}{2} \rfloor $}
\State $f_{i,j} \gets (T \textnormal{ mod } \mathfrak{p}) \cdot f_{i-1,j-1} + g\cdot f_{i-1,j-2}^q + \Delta \cdot f_{i-1,j-3}^{q^2}$
\EndFor
\EndFor

\For{$i=0 \textbf{ to } \lfloor \frac{n}{2} \rfloor$}
\For{$j = 0 \textbf{ to } \lfloor \frac{n}{2} \rfloor $}
\State $A[j,i] \gets f_{i,2j} $
\EndFor
\EndFor

\For{$j=0 \textbf{ to } \lfloor \frac{n}{2} \rfloor$}
\State $ \alpha[j] \gets (-1)^nN_{L/\mathbb{F}_q}(\Delta)^{-1} \sum_{\lfloor (2j+n)/2 \rfloor \leq i \leq n} p_i f_{i,2j + n}$
\EndFor

\State Solve $Ax = \alpha$ 
\State \textbf{Return} x
%\If {$i > \textit{stringlen}$} \Return false
%\EndIf
%\State $j \gets \textit{patlen}$
%\If {$\textit{string}(i) = \textit{path}(j)$}
%\State $j \gets j-1$.
%\State $i \gets i-1$.
%\State \textbf{goto} \emph{loop}.
%\State \textbf{close};
%\EndIf
%\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
%\State \textbf{goto} \emph{top}.
\EndProcedure
\end{algorithmic}
\end{algorithm}

%To do this, we make use of the algorithm described in theorem 4 for multiplying skew polynomials to compute $\phi_{T^i}$ for $i \leq \frac{n}{2}$, which has a total complexity of $n^{\omega + 1}$. The total complexity for determining the characteristic polynomial is therefore $n^{\omega + 1}$.





\subsection{The Case $L = K$}

Gekeler in \cite{frobdist} gives a much simpler algorithm in the case where $L = K$. In analogy with the elliptic case, we may define the Hasse Invariant $h_{\phi}$ for a rank-2 Drinfeld module. 
\begin{definition}
Let $(q, \mathfrak{f}, \mathfrak{p}, g, \delta)$ be a rank-2 drinfeld module with $\mathfrak{f} = 0$. We define the \textbf{Hasse invariant} $h_{\phi}$ of $\phi$ to be the coefficient of $X^{n}$ in $\phi_{\mathfrak{p}}$.
\end{definition}


\begin{theorem}

Let $(g,\Delta)$ be a rank-2 Drinfeld module, $L = \mathbb{F}_q[T]/\mathfrak{p}$, $[L : \mathbb{F}_q] = n$. We let $g_i$ for $i \leq n$ be the sequence defined by $g_0 = 1$, $g_1 = g$ and

\[ g_{k+1} = g^{q^{k}} g_{k} - (T^{q^{k}} - T) \Delta^{q^{k-1}} g_{k-1}.\]

\noindent Then $\gamma(a) = h_{\phi} = g_n$

\end{theorem}

Using fast modular composition and techniques for solving linear recurrences with polynomial coefficients as given in \cite{eschost2017arXiv171200669D}, we obtain a runtime for solving the recurrence for $g_n$ of $O\big(n^{(1-\beta)(\omega - 1)/2 + (\omega + 1)/2 } + M(n^{1 + \beta} \log qn) \big)$ $\mathbb{F}_q$ operations for any positive constant $\beta < 1$. Again making use of Kedlaya-Umans modular composition, all of $g^{q^i}$, $\Delta^{q^i}$, and $T^{q^i} - T$ for $i < n$ can be computed in $O( n^{2 + \epsilon} \log^{1 + o(1)} q)$ bit operations, and therefore $g_n$ can be computed with the same asymptotic cost.

\subsection{Narayanan's Algorithm}

A first randomized approach based on computing minimal polynomials of sequences due to Narayanan \cite[3.1]{DBLP:journals/corr/Narayanan15}, is below. This algorithm works only for Drinfeld modules where $\textnormal{CharPoly}(\phi_T) = \minpol(\phi_T)$, which holds for generic choices of $g$ and $\Delta$; that is, for more than half of all elements of the parameter domain \cite[theorem 3.6]{DBLP:journals/corr/Narayanan15}. It further requires that the automorphism power projection algorithm of Kaltofen and Shoup can be extended elements of $L[X,\sigma]$. Narayanan stated the latter assumption as a fact, and although he was contacted regarding this statement, no resolution regarding whether it holds was reached.

We first state the following lemma due to Kaltofen and Saunders \cite{Kaltofen-saun:1991:WMS:646027.676885} :

\begin{lemma}\label{kalsaun}
Let $A$ be an $n\times n$ matrix over a field $F$, $u: F^n \to F$ a linear map, and $b$ a vector of length $n$ whose entries come from a set $S \subset F$. Then:

\[ \textnormal{Prob}\big[\textnormal{MinPoly}(\{uA^ib\}_i) = \textnormal{MinPoly}(\{A^ib\}_i)\big] \geq 1 - \frac{\textnormal{deg}(\textnormal{MinPoly}(\{A^ib\}_i))}{2|S|} \]

\noindent and

\[ \textnormal{Prob}\big[\textnormal{MinPoly}(\{A^ib\}_i) = \textnormal{MinPoly}(\{A^i\}_i)\big] \geq 1 - \frac{\textnormal{deg}(\textnormal{MinPoly}(\{A^i\}_i))}{2|S|} \]

%Moreover, $\textnormal{Prob}\big[\textnormal{MinPoly}(\{A^ib\}_i) = \textnormal{MinPoly}(\{A^i\}_i)\big] $ satisfies the same bound. 


\end{lemma}


\begin{theorem}
Let $\phi = (\Delta, g)$ be a rank-2 Drinfeld module over $L$, $[L: \mathbb{F}_q] = n$, and suppose $\textnormal{CharPoly}(\phi_T) = \minpol(\phi_T)$. There exists a Monte Carlo randomized algorithm for determining the characteristic polynomial $C_{\phi} = X^2 -aX + b$ in $O(n^{(\omega_2)/2 + o(1)}\log^{1+o(1)}q + n^{1+o(1)}\log^{2+o(1)}q)$ $\mathbb{F}_q$ field operations.
\end{theorem}

\begin{proof}

Choose an $\alpha \in L$ and an $\mathbb{F}_q$ linear map $\ell: L \to \mathbb{F}_q$ uniformly at random. By Lemma \ref{kalsaun}, with probability at least half and at least $1 - \frac{n}{2q}$, $\textnormal{MinPoly}(\{\ell(\phi_T^i(\alpha)\}_i) = \minpol(\phi_T)$. The determination of $\textnormal{MinPoly}(\{\ell(\phi_T^i(\alpha)\}_i)$ can be done using the Berlekamp-Massey algorithm in time $O(n^{1+ o(1)} \log q)$ using the first $2n - 1$ entries. Narayanan claims that computing the collection $\{ \ell(\phi_T^i(\alpha)\}_{i=0}^{2n-2}$ is a restatement of the automorphism projection problem for elements of the endomorphism ring $L\{\sigma\}$, for which the algorithm of Kedlaya-Umans in \cite{Kedlaya:2011:FPF:2340436.2340448} yields a runtime of $O(n^{(\omega_2)/2 + o(1)}\log^{1+o(1)}q + n^{1+o(1)}\log^{2+o(1)}q)$ bit operations.
\end{proof}



\section{New Algorithms for Computing the Characteristic Polynomial}

%The characterization of Drinfeld modules given in \cite{frobdist} depends heavily upon their \textit{characteristic polynomial}.  We now present three new algorithms for computing the characteristic polynomial of a rank 2 Drinfeld module.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\subsection{A New Randomized Algorithm}

\begin{theorem}
Let $\phi = (\Delta, g)$ be a rank-2 Drinfeld module over $L$, $[L: \mathbb{F}_q] = n$. There exists a Monte Carlo randomized algorithm for determining the characteristic polynomial $C_{\phi} = X^2 -aX + b$ in $\widetilde{O}(n^2 \log q)$ $\mathbb{F}_q$ operations.
\end{theorem}

\begin{proof}
Letting $\tau$ denote the Frobenius map $\sigma^n$, by theorem \ref{charpoly}, the characteristic equation for $\tau$ tells us that for any $\alpha \in L$

\[\tau^2(\alpha) + \phi_b(\alpha) = \phi_a(\tau(\alpha))\]

Determining $b$ using Gekeler's algorithm, we may compute the left-hand side efficiently by determining $\phi_T^i(\alpha)$ for $i \leq n$. Each individual application of $\phi_T$ requires three Frobenius operations on polynomials of degree $n$ giving an individual runtime of $O(M(n) \log q)$ and a complexity of determining $\phi_b(\alpha)$ of $O(M(n) n \log q)$.  Define $r := \alpha + \phi_b(\alpha)$ and $\ell: L \to \mathbb{F}_q$ a linear projection map, we can write down the following relations with
\[a = \sum_{i = 0}^{\floor*{n/2}}a_iT^i \in \mathbb{F}_q[T]\]

\noindent we get
\[ r = \sum_{i = 0}^{\floor*{n/2}}a_i\phi_T^i(\alpha) \].

\noindent For $j \geq 0$ this implies
\[\ell(\phi_T^j(r)) = \sum_{i = 0}^{\floor*{n/2}}a_i\ell(\phi_T^{i+j}(\alpha)),\]

\noindent which gives us the following Hankel system $H_{\kappa}$ for some parameter $\kappa$ to be determined:

\[H_{\kappa} = \begin{bmatrix}\ell(\alpha) & \ell(\phi_T(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2}}(\alpha)) \\ \vdots & \vdots & & \vdots \\ 

\ell(\phi_T^{j}(\alpha)) & \ell(\phi_T^{1+j}(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2}+j}(\alpha)) \\ \vdots & \vdots & & \vdots \\

\ell(\phi_T^{\kappa}(\alpha)) & \ell(\phi_T^{1 + \kappa }(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2} + \kappa}(\alpha))

\end{bmatrix} \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_i \\ \vdots \\ a_{\floor*{n/2}} \end{bmatrix} = \begin{bmatrix} \ell(r) \\ \ell(\phi_T(r)) \\ \vdots \\ \ell(\phi_T^j(r)) \\ \vdots  \\   \ell(\phi_T^{\kappa}(r)) \end{bmatrix} \]

%The setup of the above system depends on efficiently computing $\ell(\phi_T^i(\alpha))$, which can be done using the automorphism power projection algorithm of Kedlaya-Umans in \cite{Kedlaya:2011:FPF:2340436.2340448} with runtime of $O(n^{\omega_2} \log^{1+o(1)}q + n^{1 + o(1)} \log^{2 + o(1)} q)$. 

There are $O(\kappa + n)$ entries of the form $\ell(\phi_T^i(\alpha)), \ell(\phi_T^i(r))$ that need to be computed. Evaluating the projection map takes $O(n)$ time on each $\phi_T^i(\alpha)$. We have $\phi_T^{i+1}(\alpha) = (T + g\sigma + \Delta \sigma^2)\phi_T^i(\alpha)$ and evaluating the operator $T + g\sigma + \Delta \sigma^2$ on an element of $L$ takes $O(M(n)\log q)$ time, giving a complexity of $O((n + \kappa)M(n)\log q)$

%The setup of the above system can be computed in a manner similar to the computation of $\phi_{b}(\alpha)$, with additional cost of $O(n^2 \log q)$ operations.
If $\kappa \in O(n)$, then the solution of the Hankel system can be solved in $O(n^2)$ operations using classical algorithms or $O(n \log^2(n))$ using algorithms due to Kaltofen \cite{kaltofen1994}. It remains to show $\kappa \in O(n)$. This depends in part on a lemma of Kaltofen and Pan \cite{Kaltofen:1991:PEP:113379.113396}

\begin{lemma}\label{kalpan}
Let $\{a_i\}_{i=0}^{\infty}$ be a linear sequence over $\mathbb{F}_q$ and $d$ the degree of its minimal polynomial. For any $m > 0$ let $T_m$ be the matrix given by:

\[\begin{bmatrix} a_0 && a_1 && \ldots && a_{m-1} \\ a_1 && a_2 && \ldots && a_{m} \\ \vdots && \vdots && \ddots && \vdots \\ a_{m-1} && a_{m} && \ldots && a_{2m - 2}  \end{bmatrix}\]

\noindent Then $\det T_d \neq 0$ and for any $m > d$, $\det T_m = 0$.
\end{lemma}

%To see that we only require $\kappa \leq n/2$ for a unique solution, suppose that the $\phi_T$ satisfies some polynomial of degree $d$. Then we have coefficients $c_0, \ldots, c_d$ with $c_d \neq 0$ such that $c_0 \alpha + c_1 \phi_T(\alpha) + \ldots + c_d \phi_T^d(\alpha) = 0$ for any $\alpha \in L$. Rewriting this expression in terms of $\sigma$, the leading term is of the form $c_d \Delta^{q^d + 1} \sigma^d(\alpha)$. If $c_d \neq 0$, then we must have $d \geq 2n$ since $\sigma$ cannot satisfy a polynomial of lower degree. 

Since $L$ is a degree $n$ extension of $\mathbb{F}_q$ there must be a degree $n$ monic polynomial $f$ over $\mathbb{F}_q$ such that $f(\phi_T) = 0$. Now let $f$ be the minimal of $\phi_T$ with $\deg(f) = d$. For any positive integers $i,j$ with $i < j < n$, $ \sigma^i = \sigma^j$ implies $\sigma^{j-i}$ is the identity on $\mathbb{F}_{q^n}$, which can't occur since $j - i < m$. Therefore by independence of characters, $\sigma, \sigma^2, \ldots, \sigma^{n-1}$ satisfy no non-trivial $\mathbb{F}_q$-linear relation; that is, there are no constants $c_0, \ldots, c_{n-1}$ with at least one $c_i \neq 0$ such that $c_0 + c_1 \sigma + \ldots + c_{n-1}\sigma^{n-1} = 0$. So if $ 0 = f(\phi_T) = c_0 + c_1 \sigma + \ldots + c_{2d} \sigma^{2d}$, where the lead term $c_{2d} \sigma^{2d}$ is given by $(\Delta \sigma^2)^d$, so $c_{2d} = \Delta^{(1-q^{2d})/(1-q)} \neq 0$, then $2d \geq n-1$ and so $\frac{n-1}{2} \leq d = \deg \minpol(\phi_T) \leq n$.

By lemma \ref{kalsaun}, with probability at least $(1 - \frac{n}{2q})^2$ we have that $\minpol(\{\ell(\phi_T^i(\alpha)\}_i) = \minpol(\phi_T)$, in which case by lemma \ref{kalpan} and the upper bound $\deg \minpol(\phi_T) \leq n$  we can guarantee that an upper left submatrix of

\[\overline{H}_{\kappa} = \begin{bmatrix}\ell(\alpha) & \ell(\phi_T(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2}}(\alpha)) & \ell(\phi_T^{\floor*{n/2} + 1}(\alpha)) & \ldots & \ell(\phi_T^{2\floor{n/2}}(\alpha))

\\ \vdots & \vdots & & \vdots & \vdots & & \vdots \\ 

\ell(\phi_T^{j}(\alpha)) & \ell(\phi_T^{1+j}(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2}+j}(\alpha)) & \ell(\phi_T^{\floor*{n/2} +j + 1}(\alpha)) & \ldots & \ell(\phi_T^{2\floor{n/2} + j}(\alpha))

\\ \vdots & \vdots & & \vdots & \vdots & & \vdots \\

\ell(\phi_T^{\kappa}(\alpha)) & \ell(\phi_T^{1 + \kappa }(\alpha)) & \ldots & \ell(\phi_T^{\floor*{n/2} + \kappa}(\alpha) & \ell(\phi_T^{\floor*{n/2} + \kappa + 1}(\alpha)) & \ldots & \ell(\phi_T^{2\floor{n/2} + \kappa}(\alpha)))

\end{bmatrix} \]
\noindent of size at least $\frac{n-1}{2}$ is invertible when $\kappa = \minpol(\{\ell(\phi_T^i(\alpha)\}_i)$ and $\frac{n-1}{2} \leq \kappa \leq n$. Therefore a solution to the system

\[\overline{H}_{\kappa}\begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_i \\ \vdots \\ a_{\floor*{n/2}} \\ a_0 \\ a_1 \\ \vdots \\ a_i \\ \vdots \\ a_{\floor*{n/2}} \end{bmatrix} = 
\begin{bmatrix} \ell(r) + \ell(\phi_T^{\floor*{n/2}}(r)) \\ \ell(\phi_T(r)) + \ell(\phi_T^{\floor*{n/2 + 1}}(r))  \\ \vdots \\ \ell(\phi_T^j(r)) + + \ell(\phi_T^{\floor*{n/2} + j}(r))  \\ \vdots  \\   \ell(\phi_T^{\kappa}(r)) + \ell(\phi_T^{\floor*{n/2} + \kappa}(r))  \end{bmatrix} \]

\noindent determines unique values for $a_0, \ldots, a_{\floor*{n/2}}$ with probability at least $(1 - \frac{n}{2q})^2$. We may determine the value of $\kappa$ using the Berlekamp-Massey algorithm in $O(n^2)$ operations. One final observation is that when $n$ is even and $\deg \minpol(\phi_T) = \frac{n}{2}$, then the invertible upper left matrix guaranteeing uniqueness has dimension $\frac{n}{2}$, which does not guarantee a unique solution for $a_{n/2}$. Using \cite[proposition 2.14]{frobdist}, this coefficient may be computed as

\[a_{n/2} = Tr_{\mathbb{F}_{q^2}/\mathbb{F}_{q}}(N_{L/\mathbb{F}_{q^2}}(\Delta)^{-1})\]

\noindent where $\mathbb{F}_{q^2}$ is the unique degree 2 extension of $\mathbb{F}_q$ contained in $\mathbb{F}_{q^n}$. Using $Tr_{\mathbb{F}_{q^2}/\mathbb{F}_{q}}(x) = x + x^q$ we can compute $a_{n/2}$ in $O(M(n)(\log n + \log q))$ $\mathbb{F}_q$ operations.

%$N_{\mathbb{F}_{q^2}/ \mathbb{F}_q}(x) = x^{q^2 + 1}$, and $N_{L/\mathbb{F}_q} = N_{L/\mathbb{F}_{q^2}} \circ N_{\mathbb{F}_{q^2}/ \mathbb{F}_q}$,

%Moreover for the linear sequence $\{\ell(\phi_T^{i}(\alpha)) \}_{i=0}^{\infty} $, $\minpol( \{ a_i\}_{i=0}^{\infty} ) | \minpol(\phi_T)$, 

%so for generic $\ell, \alpha$ we have that $\minpol( \{ a_i\}_{i=0}^{\infty} ) = \minpol(\phi_T)$. Moreover $\phi_T$ satisfies a polynomial of degree at most $n$, so from lemma 4, the matrix $T_{\kappa}$ is invertible for some $\frac{n}{2} \leq \kappa \leq n$, guaranteeing a unique solution.


\end{proof}

 \begin{algorithm}
\caption{A New Randomized Algorithm for Finding the Frobenius Trace}\label{euclid}
\begin{algorithmic}[1]
\Procedure{RandomizedFrobeniusTrace}{} \\
\hspace*{\algorithmicindent} \textbf{Input} A rank-2 Drinfeld Module $(q,\frakf,\mathfrak{p}, g, \Delta)$ and Frobenius Norm $b$\\
 \hspace*{\algorithmicindent} \textbf{Output} The Frobenius Trace $a$
 
 \State Choose a map $\ell: L \to \mathbb{F}_q$ uniformly at random from $\mathbb{F}_q^n$
 \State Choose an element $\alpha \in L$ uniformly at random from $L$
\State $r \gets \alpha + \phi_b(\alpha)$
\State $A[0] \gets \alpha$
\State $B[0] \gets r$
\For{$i=1 \textbf{ to } \lfloor \frac{n-1}{2} \rfloor$}
\State $B[i] = \phi_T(\phi_T^{i-1}(r))$
\State $B[i-1] \gets \ell(B[i-1])$
\EndFor
\For{$i=1 \textbf{ to } n-1$}
\State $A[i] = \phi_T(\phi_T^{i-1}(\alpha))$
\State $A[i-1] \gets \ell(A[i-1])$
\EndFor
\For{$i=0 \textbf{ to } \lfloor \frac{n-1}{2} \rfloor$}
\For{$j=0 \textbf{ to } \lfloor \frac{n}{2} \rfloor$}
\State $M[i,j] = A[i + j]$
\EndFor
\EndFor

\State Solve Hankel system $Mx = B$
\Return $x$
%\If {$i > \textit{stringlen}$} \Return false
%\EndIf
%\State $j \gets \textit{patlen}$

%\If {$\textit{string}(i) = \textit{path}(j)$}
%\State $j \gets j-1$.
%\State $i \gets i-1$.
%\State \textbf{goto} \emph{loop}.
%\State \textbf{close};
%\EndIf
%\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
%\State \textbf{goto} \emph{top}.
\EndProcedure
\end{algorithmic}
\end{algorithm}



% add
% Genericity 

%The values $\phi_T^i$ can be computed as before in time $\widetilde{O}(n^2 \log q)$ [alternatively use power projection for improved runtime - see Narayanan]. 


%It remains to determine the probability that the minimal polynomial of the sequence corresponds to the minimal polynomial of $\phi_T$. 

%This algorithm is virtually identical to the one given in \cite{Wiedemann:1986:SSL:13738.13744}, by which it follows that, given $k$ minimal polynomial computations and taking their lcm, the probability that this is the minimal polynomial of $\phi_T$ is at least $1 - \log  \frac{q^{k-1}}{q^{k-1} - 1} $. For any $q \geq 2$ after two trials this probability is at least a half, and so we require $O(\log(\delta))$ trials to obtain a probability of success at least $1 - \delta$.


\subsection{Schoof's Algorithm for Drinfeld modules}

We present here an alternative approach inspired by Schoof's algorithm for elliptic curves. Supposing $ \frac{n}{2} + 1 < q$, for some choice of elements $e_0, e_1, \ldots, e_{n/2} \in \mathbb{F}_q$, we aim to compute $a(e_i)$. Invoking either the Universal Property of Quotients for rings, or the observation that $\phi_{a + r(T-e_i)} = \phi_a + \phi_{r} \phi_{T- e_i}$, this can be determined using $\phi_a \textnormal{ (mod } \phi_{T - e_i} \textnormal{)} = \phi_{a(e_i)} = a(e_i)$ for each index $i$. Reducing the characteristic equation mod $\phi_{T- e_i}$ we obtain

\begin{equation}\label{charmodpol}
 a(e_i) \sigma^n  = \sigma^{2n} + b(e_i) \textnormal{ (mod } \phi_{T} - e_i \textnormal{)}.
 \end{equation}

\noindent Therefore it is sufficient to determine

\[\sigma^{n} \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} \]

\noindent for each $e_i$ and solve for $a$ satisfying equation \ref{charmodpol}. 

\begin{theorem}

Let $\phi = (\Delta, g)$ be a rank-2 Drinfeld module over $L$, $[L: \mathbb{F}_q] = n$. There exists a deterministic algorithm for determining the characteristic polynomial $C_{\phi} = X^2 -aX + b$ in
\begin{itemize}
\item $\widetilde{O}(n^{\omega_2/2 + 1} + n^2 \log q)$ $\mathbb{F}_q$ operations

\item $\widetilde{O}(n^{2+\delta} \log^{1 + o(1)} q)$ bit operations for any $\delta > 0$.
\end{itemize}

\end{theorem}

\begin{proof}
Let 

\[ \sigma^j = \nu_j + \mu_j \sigma \textnormal{ (mod } \phi_{T} - e_i \textnormal{)}\]

\noindent for $\nu_j, \mu_j \in L$ and let $\gamma(T) = \gamma_T$. Then we obtain the recurrence relation:

\[\sigma^{j+1} = \nu_j^q \sigma + \mu_j^q \sigma^2 = \nu_j^q \sigma + \mu_i^q\big( -\frac{\gamma_T - e_i}{\Delta} - \frac{g}{\Delta} \sigma \big) \textnormal{ (mod } \phi_{T} - e_i \textnormal{)}. \]

\noindent That is, $\nu_{j+1} = -\frac{\gamma_T - e_i}{\Delta}\mu_{j}^q$ and $\mu_{j + 1} = \nu_j^q - \frac{g}{\Delta} \mu_j^q$. Letting $\alpha = -\frac{\gamma_T - e_i}{\Delta}$, $\beta = - \frac{g}{\Delta}$, and

\[ M^{(q^i)} = \begin{bmatrix} 0 & \alpha^{q^i} \\ 1 & \beta^{q^i} \end{bmatrix} \]

\[ \begin{bmatrix} \nu_{n} \\ \mu_n  \end{bmatrix} = M M^{(q)} \ldots M^{(q^{n-1})}  \begin{bmatrix} 1 \\ 0  \end{bmatrix}. \]

%\[ \begin{bmatrix} \nu_{n} \\ \mu_n  \end{bmatrix} = \displaystyle\prod_{i = 0}^{n-1}M_i  \begin{bmatrix} 1 \\ 0  \end{bmatrix} \]

\noindent Therefore, efficiently computing $\sigma^n$ relies on computing the products $ P_j = M M^{(q)} \ldots M^{(q^j)}$. This can be done effectively using the following observation:

\[ P_{2j + 1} = P_{j} P_{j}^{(q^{j+1})}.\]

\noindent We then compute $\sigma^{2n}$ as
\begin{align*}
\sigma^{2n} & = (\nu_n + \mu_n \sigma)(\nu_n + \mu_n \sigma) & \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} \\
 & = \nu_n^2 + \nu_n\mu_n \sigma + \mu_n\nu_n^q \sigma + \mu_n^{q+1} (\alpha + \beta \sigma) & \textnormal{ (mod } \phi_{T} - e_i \textnormal{)}\\
 & = \nu_n^2 + \mu_n^{q + 1} \alpha + (\nu_n \mu_n + \mu_n \nu_n^q + \mu_n^{q+1}\beta)\sigma & \textnormal{ (mod } \phi_{T} - e_i \textnormal{)}
\end{align*}

\noindent Substituting back into \ref{charmodpol} results in the relation

\begin{equation} \label{reduct}
a(e_i) (\nu_n + \mu_n \sigma) = \nu_n^2 + \mu_n^{q + 1} \alpha + b(e_i) + (\nu_n \mu_n + \mu_n \nu_n^q + \mu_n^{q+1}\beta)\sigma \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} .
\end{equation}

\noindent Therefore when $\mu_n \neq 0$ we conclude that

\[a(e_i) = \nu_n + \nu_n^q + \mu_n^q \beta \]

\noindent which allows the determination of $a(e_i)$ without computing the Frobenius norm beforehand. Otherwise, \ref{reduct} gives

\begin{equation}
a(e_i) = \nu_n + b(e_i)
\end{equation}

\noindent when $\mu_n = 0$.

The algorithm may be summarized as follows:

\begin{enumerate}

\item Compute $\sigma^n  \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} $ by computing $P_n$.

%using $\log(n)$ multiplications and $q^n$ exponentiations.

\item Solve for $a(e_i) \in \mathbb{F}_q$ such that $a(e_i)\sigma^n = \sigma^{2n}+ b(e_i)  \textnormal{ (mod } \phi_{T} - e \textnormal{)} $.

\item Interpolate the values $a(e_i)$.

\end{enumerate}

The only potential degeneracy occurs when $\sigma^n = 0 \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} $, which can be excluded when $\gamma_T \neq e_i$. Suppose $\sigma^n = \sum_{i=0}^{n-2} a_i \sigma^i(\phi_T - e_i)$. Then clearly $a_0 = 0$ if $\gamma_T - e \neq 0$. Moreover, if $a_i = 0$ for all $i < d < n - 2$, then $0 = a_{d} (\gamma_T - e_i)^d + a_{d-1}g^{d-1} + a_{d-2} \Delta^{d-2} = a_{d} (\gamma_T - e_i)^d$, therefore $a_d = 0$. So $\sigma^n = a_{n-2} \sigma^{n-2} \sigma^i(\phi_T - e_i)$ which is a contradiction.

We can compute polynomial representations for all $\sigma^i$ beforehand using modular composition for at most $O(\log n)$ choices of index $i$. Next, for each $e_i$, we perform $O(\log n)$ $2\times 2$ matrix multiplications and modular compositions to evaluate the Frobenius map up to order $q^{n/2}$. These two steps together contribute $O(n^{\omega_2/2} \log n + M(n) \log q )$ $\mathbb{F}_q$ operations using Brent-Kung composition, or $O(n^{1+\delta} \log^{1 + o(1)} q \log n)$ bit operations, for any $\delta > 0$, using Kedlaya-Umans. Repeating for $\frac{n}{2} + 1$ choices of $e_i$ raises the cost in either case by a factor of $O(n)$. The interpolation step takes at most $O(n^2)$ operations, so the total cost remains either $O(n^{\omega_2/2 + 1} \log n + M(n) n \log q)$ $\mathbb{F}_q$ operations  or $O(n^{2+\delta} \log^{1 + o(1)} q \log n)$ bit operations

\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% Work here %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For the case where $\frac{n}{2} + 1 > q$, we now instead aim to compute $\sigma^n \textnormal{ mod } \phi_{g_i}$ for pairwise co-prime polynomials $\{g_i\}_{i=0}^{t}$ of degrees $d_i$ such that $\sum_{i} d_i > \frac{n}{2}$. Here we let:

\begin{align*}
\phi_{g_i} & = \sum_{\ell = 0}^{2d_i} c_{i,\ell} \sigma^{\ell} & \\
\sigma^{j} & = \sum_{k=0}^{2d_i-1}a_{i,j,k}\sigma^k & \textnormal{ (mod } g_i \textnormal{)} \\
\sigma^{j+1} & =  \sum_{k=0}^{2d_i-2}a_{i,j,k}^q\sigma^{k+1} - a_{i,j,2d_i-1}^q\sum_{\ell = 0}^{2d_i - 1} \frac{c_{i,\ell}}{c_{i,2d_i}} \sigma^{\ell}  & \textnormal{ (mod } g_i \textnormal{)}\\
 & = -a_{i,j,2d_i -1}\frac{c_{i,0}}{c_{i,2d_i}} + \sum_{k=1}^{2d_{i}-1} \bigg( a_{i,j,k -1}^q - a_{i,j,2d_i-1}^q\frac{c_{i,k}}{c_{i,2d_i}}\bigg)\sigma^k & \textnormal{ (mod } g_i \textnormal{)}
\end{align*}

Defining $\alpha_{i,k} = -\frac{c_{i,k}}{c_{i,2d_i}}$, we have

\[M = \begin{bmatrix} 0 & 0 & 0 & \ldots & 0 & \alpha_{i,0} \\
                      1 & 0 & 0 & \ldots & 0 & \alpha_{i,1} \\
                      0 & 1 & 0 & \ldots & 0 & \alpha_{i,2} \\
                      0 & 0 & 1 & \ldots & 0 & \alpha_{i,3} \\
                      \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
                      0 & 0 & 0 & \ldots & 1 & \alpha_{i,2d_i - 1}
\end{bmatrix}\]

Utilising the same notation as before, we have:

\[ \begin{bmatrix} a_{i,n,0} \\ a_{i,n,1} \\ \vdots \\ a_{i,n,2d_i -1} \end{bmatrix} = MM^{(q)} \ldots M^{(q^{n-1})} \begin{bmatrix}1 \\ 0 \\ 0 \\ \ldots \\ 0 \end{bmatrix}\]

Since the number of irreducible polynomials grows exponentially, we can require $d_i \leq d \in O(\log n)$ in order to guarantee $\sum_{i} d_i > \frac{n}{2}$. To select our irreducible polynomials, we can use the factor refinement technique introduced in \cite{Bach:1993:FR:158390.158392} on the set of all polynomials of degree $d$ which runs in $O(n^2)$ bit operations.

Computing the $\alpha_{i,k}$ requires computing $\phi_{g_i}$, which we can do for all $i$ efficiently by computing $\phi_T, \ldots, \phi_{T^d}$ by using efficient algorithms for skew polynomial multiplication which are quadratic in $d$. The complexity analysis follows the same approach as before, with an additional $\log n$ factor for the number of applications of the Frobenius maps $\sigma^j$. 

To recombine the individual modular computations, we recall that given coprime elements $p,q$, if $x = a \mod p$ and $x = b \mod q$, if $pp^{-1} = 1 \mod q$ and $qq^{-1} = 1 \mod p$, then we have $x = aqq^{-1} + bpp^{-1} \mod pq$. Using algorithms for multiplication and division due to Puchinger and Wachter-Zeh \cite{PUCHINGER2017}, both operations can be done in time at worst $\otilde{O}(n^{\omega_2/2} \log q)$. Performing up to $O(n)$ recombinations gives an overall recombination cost of $\otilde{O}(n^{\omega_2/2 + 1} \log q)$

The overall runtime in the general case is $O(n^{\omega_2/2 + 1} \log^2 n \log q + M(n) n \log q \log n)$ $\mathbb{F}_q$ operations  or $O(n^{2+\delta} \log^{1 + o(1)} q \log^2 n)$ bit operations.  



%We expect the algorithm may be extended to the case $\frac{n}{2} + 1 > q$ by computing $\sigma^n \textnormal{ mod } \phi_g$ for irreducible polynomials $g$, though an exposition of this approach will not be given. 

 \begin{algorithm}
\caption{Schoof's Algorithm for Drinfeld modules}\label{euclid}
\begin{algorithmic}[1]
\Procedure{FrobeniusTrace}{} \\
\hspace*{\algorithmicindent} \textbf{Input} A rank-2 Drinfeld Module $(q,\frakf,\mathfrak{p}, g, \Delta)$ and Frobenius Norm $b$\\
 \hspace*{\algorithmicindent} \textbf{Output} The Frobenius Trace $a$
 
 \State $E \gets \{e_0, \ldots, e_{n/2}\} \subset \mathbb{F}_q$

\State $\sigma \gets x^q$ mod $\mathfrak{f}$
\While{$i < n$}
\If{$2i + 1 < n$}
\State $\sigma^{i + 1} \gets \sigma^i \circ \sigma$
\State $\sigma^{2i + 1} \gets \sigma^i \circ \sigma^i \circ \sigma$
\State $i \gets 2i+1$
\Else
\State $\sigma^{i+1} \gets \sigma^i \circ \sigma$
\State $i \gets i+1$
\EndIf
\EndWhile
 
\For{$e_i \in E$}
\State $\alpha \gets -(\gamma_T - e_i)/\Delta$
\State $\beta \gets -g/\Delta$

\State $P_0 \gets \begin{bmatrix} 0 & \alpha \\ 1 & \beta \end{bmatrix}$
\State $i \gets 0$
\While{$i < n-1$}
\If{$2i + 1 < n$}
\State $P_i^{\sigma^{i+1}} \gets \begin{bmatrix} P_{i}[0,0](\sigma^{i+1}) & P_{i}[0,1](\sigma^{i+1}) \\ P_{i}[1,0](\sigma^{i+1}) & P_{i}[1,1](\sigma^{i+1}) \end{bmatrix}$
\State $P_{2i+1} \gets P_iP_i^{\sigma^{i+1}}$

\State $i \gets 2i+1$
\Else
\State $M_i \gets \begin{bmatrix} 0 & \alpha(\sigma^{i}) \\ 1 & \beta(\sigma^{i}) \end{bmatrix}$
\State $P_{i+1} \gets P_iM_i$
\State $i \gets i+1$
\EndIf
\EndWhile

\State $\nu_{n} \gets P_{n-1}[0,0]$
\State $\mu_n \gets P_{n-1}[1,0]$
\If{$\mu_n \neq 0$}
\State $a(e_i) \gets \nu_n + \nu_n^q + \mu_n^q \beta$
\Else
\State $a(e_i) \gets \nu_n + b(e_i)$
\EndIf
\EndFor
\Return $\textbf{Interpolate}(\{ (e_0, a(e_0)), (e_1, a(e_1)), \ldots, (e_{n/2}, a(e_{n/2})) \})$
%\If {$i > \textit{stringlen}$} \Return false
%\EndIf
%\State $j \gets \textit{patlen}$

%\If {$\textit{string}(i) = \textit{path}(j)$}
%\State $j \gets j-1$.
%\State $i \gets i-1$.
%\State \textbf{goto} \emph{loop}.
%\State \textbf{close};
%\EndIf
%\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
%\State \textbf{goto} \emph{top}.
\EndProcedure
\end{algorithmic}
\end{algorithm}

%\begin{lemma}
%Suppose $e_i \neq \gamma_T$. Then  $\sigma^n \neq 0 \textnormal{ (mod } \phi_{T} - e_i \textnormal{)} $
%\end{lemma}

%\begin{proof}
%. Then we have for all $d < n - 2$:


%\[ 0 = \sum_{i+j= d } a_i (\gamma_T - e)^{q^i} + \sum_{i+j + 1 =d} a_i g^{q^i} + \sum_{i+j + 2 = d} a_i \Delta^{q^i}\]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\[ 0 = \sum_{i+j= d } a_i (\gamma_T - e)^{q^i} + \sum_{i+j + 1 =d} a_i g^{q^i} + \sum_{i+j + 2 = d} a_i \Delta^{q^i}\]

%for all $d < n - 2$, and

%\[ 1 = \sum_{i+j + 2 = n} a_i b_j^{q^i} \Delta^{q^i} (2)\]

%We show that $a_ib_j = 0$ for $i + j = d$ for all $d < n - 2$. The base case follows trivially from equation (1) above since $a_0b_0 (\gamma_T - e) = 0$. For the inductive case, note that

%\[ 0 = \sum_{i+j= d } a_i b_j^{q^i} (\gamma_T - e)^{q^i} \]

%If some $a_ib_j \neq 0$, then $a_{i'}b_{j'} \neq 0$ for some $i \neq i'$, $j \neq j'$. Then without loss of generality $i < i'$, so $a_ib_{j'} \neq 0$ but $i + j' < d$, yielding a contradiction and the desired sub-lemma.

%Then we must have:

%\[1 = a_ub_v^{q^u} (\gamma_T - e)^{q^u} \]

%So $a_u, b_v \neq 0$. Hence by the sub-lemma $a_i = 0$ and $b_j = 0$ for all $i < u$, $j < v$. This leaves

%\[\sigma^n = a\sigma^{u} (\gamma_T - e + g\sigma + \Delta \sigma^2  ) b \sigma^v\]

%Which does not hold for any choice of $a,b$.



%\end{proof}

\begin{example}
Let $q = 5$, $n = 4$. Then $L = \mathbb{F}_5[T]/(T^4 + 4T^2 + 4T + 2)$. Take $\phi$ to be a rank-2 Drinfeld module over $L$ with $g = 1, \Delta = 1$. Then for $e_0 = 0$ we have $\alpha = 4t$, $\beta = 4$. Letting

\[M = \begin{bmatrix}0 & 4T \\ 1 & 4 \end{bmatrix}.\]

\noindent We get:

\[M M^{5} M^{25} M^{125} = \begin{bmatrix} T^3 + T^2 + 3 & T^3 + 2T + 3 \\ 2T^3 + 2T^2 + 3T + 4 & 4T^3 + 4T^2 + 4 \end{bmatrix}\]

\noindent So $\nu_4 = T^3 + T^2 + 3$ and $\mu_4 = 2T^3 + 2T^2 + 3T + 4$ and

\[a(0) = \nu_4 + \nu_4^5 + 4\mu_4^5 = 2\]

\noindent For $e_1 = 1$ we have 

\begin{align*}
M & = \begin{bmatrix}0 & 4t + 1 \\ 1 & 4 \end{bmatrix}\\
M M^{5} M^{25} M^{125} & = \begin{bmatrix} 4T & 4T^2 \\ 2T^3 + 2T^2 + 3T + 2 & T+3 \end{bmatrix}
\end{align*}

\noindent and we get $a(1) = 3$. Repeating this calculation once more yields $a(2) = 3$ and we can interpolate to get

\[a = (T-1)(T-2) + 2T(T-2) + 4T(T-1)   = 2T^2 + 4T + 2.\]

\end{example}
%The runtime of the algorithm is dominated by the interpolation step, taking $O(n^2)$ time, and the computation of the matrix, which takes $O(M(n)\log(n)^2\log(q))$.

\section{Computational Results}

We attempted to verify the runtime of the two new algorithms presented here with an implementation using SageMath \cite{sagemath}. The rank-2 Drinfeld module with parameters $g = 1$, $\Delta = 1$ was used for all computations. The runtimes shown in tables \ref{tab:table1} and \ref{tab:table2} are for fields of characteristic $ p= 1299827$ and $ p = 179426549$ for varying values of $k$ such that the base field has order $q = p^k$, and $n = [L: \mathbb{F}_q]$ was fixed at $ n = 6$. The values given are the averages over 10 trials. The results appear to confirm the logarithmic dependence on $q$ for both new algorithms. 

\begin{center}
\begin{tabular}{ | m{2cm} | m{3cm}| m{3cm} | } 
%\caption{A summary of the computational results}
\hline
 & $p = 1299827$ & $p = 179426549 $ \\ 
\hline
$k = 1$ & 0.0791 & 0.0951 \\ 
\hline
$k = 3$ & 1.1438 & 1.418019056\\
\hline 

$k = 6$ &5.3689 & 11.35429311\\

\hline
\end{tabular}
\end{center}
\begin{table}[h!]
  \centering
  \caption{Runtime in seconds of our new randomized algorithm when $q = p^k$ and $n = 6$}
  \label{tab:table1}
\end{table}


\begin{center}
\begin{tabular}{ | m{2cm} | m{3cm}| m{3cm} | } 
%\caption{A summary of the computational results}
\hline
 & $p = 1299827$ & $p = 179426549 $ \\ 
\hline
$k = 1$ & 0.0791 & 0.0951 \\ 
\hline
$k = 3$ & 1.1438 & 1.418019056\\
\hline 

$k = 6$ &5.3689 & 11.35429311\\

\hline
\end{tabular}
\end{center}
\begin{table}[h!]
  \centering
  \caption{Runtime in seconds of our new deterministic algorithm when $q = p^k$ and $n = 6$}
  \label{tab:table2}
\end{table}


We then attempted to verify the order of dependence on $n$ by producing a log-log plot on $n$ versus runtime. Logarithms are taken base 2, and results are averaged over 10 trials. The linear regressions for our randomized algorithm shown in figures \ref{fig:figure1} and \ref{fig:figure2} have slopes below 3, which is consistent with the sub-cubic runtime given by our analysis.

In contrast, our linear regression for the deterministic algorithm exceeds 3. This is almost certainly due to difficulties in finding library implementations for fast modular composition. The only reference implementations we could find worked only in the case where the base field was $\mathbb{F}_2$, which due to the requirement $q > \frac{n}{2} + 1$ was insufficient for testing our deterministic algorithm. Efforts to produce our own general implementation of fast modular composition were unsuccessful in the time available.

\begin{figure}\label{fig:figure1}
\centering
  \includegraphics[width=6in]{chart2-1}
  \caption{Log-log plot of $n$ versus runtime with $p = 2$, $k = 1$ for our new randomized algorithm}
\end{figure}

\begin{figure}\label{fig:figure2}
\centering
  \includegraphics[width=6in]{chart31-1}
  \caption{Log-log plot of $n$ versus runtime with $p = 31$, $k = 2$ for our new randomized algorithm}
\end{figure}

\begin{figure}\label{fig:figure3}
\centering
  \includegraphics[width=6in]{chart31-2}
  \caption{Log-log plot of $n$ versus runtime with $p = 31$, $k = 2$ for our new deterministic algorithm}
\end{figure}






%    Text of article.

%    Bibliographies can be prepared with BibTeX using amsplain,
%    amsalpha, or (for "historical" overviews) natbib style.
\bibliography{sample}{}
\bibliographystyle{amsplain}
%    Insert the bibliography data here.

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%    Templates for common elements of a journal article; for additional
%    information, see the AMS-LaTeX instructions manual, instr-l.pdf,
%    included in the JAMS author package, and the amsthm user's guide,
%    linked from http://www.ams.org/tex/amslatex.html .

%    Section headings
\section{}
\subsection{}

%    Ordinary theorem and proof
\begin{theorem}[Optional addition to theorem head]
% text of theorem
\end{theorem}

\begin{proof}[Optional replacement proof heading]
% text of proof
\end{proof}

%    Figure insertion; default placement is top; if the figure occupies
%    more than 75% of a page, the [p] option should be specified.
\begin{figure}
\includegraphics{filename}
\caption{text of caption}
\label{}
\end{figure}

%    Mathematical displays; for additional information, see the amsmath
%    user's guide, linked from http://www.ams.org/tex/amslatex.html .

% Numbered equation
\begin{equation}
\end{equation}

% Unnumbered equation
\begin{equation*}
\end{equation*}

% Aligned equations
\begin{align}
  &  \\
  &
\end{align}

%-----------------------------------------------------------------------
% End of jams-l-template.tex
%-----------------------------------------------------------------------